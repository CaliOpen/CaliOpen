#!/bin/env python
"""
Caliopen tool for release management.

Permit to prepare a release, build and submit it on github.

Usage:
    make_release --conf <package.yaml> --version <X.Y.Z> --prepare --build

"""

import os
import sys
import subprocess as sp
import argparse
import re

import logging
import yaml
import json

from git import Repo

log = logging.getLogger(__name__)
logging.basicConfig()
log.setLevel(logging.DEBUG)

# Some declarations
# XXX well perl from python I know, don't find simplest way than this one
UPDATE_VERSION_CMD = "perl -pi -e \"s/{version_str}{old_version}/" \
                     "{version_str}'{new_version}'/\" {file}"

COMMIT_MESSAGE = 'Release {version}'

PY_BUILD_CMD = 'python setup.py bdist_wheel --universal --dist-dir {}'
PY_VERSION_STR = "__version__ = "

JS_BUILD_CMD = 'yarn release:web:{}'
JS_UPDATE_VERSION_CMD = 'npm version "{version}" --no-git-tag-version'

GO_BUILD_CMD = 'go build'

# Files updated to consider for commit or rollback
UPDATE_FILES = []


def do_package_command(package, cmd):
    """Execute a shell command for a package."""
    log.debug(' will execute command : {}'.format(cmd))
    errno = sp.call(cmd, shell=True)
    if errno == 0:
        log.info('Build python package {} OK'.format(package['name']))
        return True
    msg = 'Build python package {} failed: {}'.format(package['name'], errno)
    raise Exception(msg)


def check_versions(current, new):
    """Compare current and new version, raise if new is not superior."""
    t_new = tuple(int(x) for x in new.split('.'))
    t_cur = tuple(int(x) for x in current.split('.'))
    if t_new <= t_cur:
        raise Exception('Current version {} and new expected one {} mismatch'.
                        format(current, new))


def update_javascript_package(package, package_dir, version):
    """Update javascript version in package.json."""
    pkg_file = '{}/package.json'.format(package_dir)
    if not os.path.isfile(pkg_file):
        raise Exception('File {} for package version not found'.
                        format(pkg_file))
    current = None
    with open(pkg_file) as v_file:
        current = json.loads(v_file.read()).get('version')
    if not current:
        raise Exception('No current version found for package {}'.
                        format(package['name']))
    log.info('Current version found for package {} is {}'.
             format(package['name'], current))
    check_versions(current, version)
    version_cmd = JS_UPDATE_VERSION_CMD.format(version=version)
    cmd = 'cd {};{}'.format(package_dir, version_cmd)
    res = do_package_command(package, cmd)
    if res:
        UPDATE_FILES.append(pkg_file)
    return res


def make_javascript_package(package, directory, version, output_directory):
    """Build javascript distribution."""
    if not os.path.isdir(directory):
        raise Exception('No such package directory {}'.format(directory))

    cmd = 'cd {}; {}'.format(directory, JS_BUILD_CMD.format(package['name']))
    res = do_package_command(package, cmd)
    if not res:
        return False
    # Move build distribution
    distdir = '{}/dist/{}'.format(directory, package['name'])
    if not os.path.isdir(distdir):
        log.error('No dist directory after build')
        sys.exit(1)
    destdir = '{}/{}'.format(output_directory, package['name'])
    os.rename(distdir, destdir)
    return True


def make_go_distribution(package, directory, version, output_directory):
    """Build go binaries for a given package and version."""
    pass


def update_python_version(package, package_dir, version):
    """Update python package version rewriting in place."""
    init_file = '{}/{}/__init__.py'.format(package_dir, package['name'])
    if not os.path.isfile(init_file):
        raise Exception('File {} for package version not found'.
                        format(init_file))
    """Update the __version__ value for a python package."""
    current = None
    with open(init_file) as v_file:
        current = re.compile(r".*__version__ = '(.*?)'",
                             re.S).match(v_file.read()).group(1)
    if not current:
        raise Exception('No current version found for package {}'.
                        format(package['name']))
    log.info('Current version found for package {} is {}'.
             format(package['name'], current))
    check_versions(current, version)
    # XXX rewrite init_file with new version
    cmd = UPDATE_VERSION_CMD.format(version_str=PY_VERSION_STR,
                                    old_version="'{}'".format(current),
                                    new_version="'{}'".format(version),
                                    file=init_file)
    log.debug('Updating python package {} to version {}'.
              format(package['name'], version))
    res = do_package_command(package, cmd)
    if res:
        UPDATE_FILES.append(init_file)
    return res


def make_python_package(package, directory, version, output_directory):
    """Make a python wheel package for a given package and version."""
    if not os.path.isdir(directory):
        raise Exception('No such package directory {}'.format(directory))
    if not update_python_version(package, directory, version):
        log.warn('Update python package version failed')
        return False

    build_cmd = PY_BUILD_CMD.format(output_directory)
    cmd = 'cd {}; {}'.format(directory, build_cmd)
    return do_package_command(package, cmd)


def make_packages(config, version, languages):
    """Given a packages dict and a version, build all."""
    all_packages = config.get('packages', {})
    basedir = get_repository_directory(config)

    output_directory = '{}/dist/{}'.format(basedir, version)
    if not os.path.isdir(output_directory):
        raise Exception('No valid output directory for release {}'.
                        format(version))

    for language, packages in all_packages.items():
        if 'all' not in languages and language not in languages:
            log.info('Skipping language {}'.format(language))
            continue
        if language in make_dist_methods:
            fn = make_dist_methods[language]
        else:
            log.error('Invalid language {}'.format(language))
            sys.exit(1)

        for package in packages:
            log.info('Building package {}'.format(package['name']))
            package_dir = '{}/{}'.format(basedir, package['path'])
            fn(package, package_dir, version, output_directory)


def get_repository_directory(config):
    """Return absolute repository directory."""
    repo = config.get('repository', {})
    basedir = repo.get('base_directory')
    assert os.path.isdir(basedir)
    return os.path.abspath(basedir)


def get_repository(basedir):
    """Return a ``Repo`` instance."""
    repo = Repo(basedir)
    assert not repo.bare, 'Repository is bare git, not valid'
    return repo


def commit_release(repo, version):
    """Commit a a release."""
    index = repo.index
    log.debug('Updated files to add : {}'.format(UPDATE_FILES))
    index.add(UPDATE_FILES)
    commit_msg = COMMIT_MESSAGE.format(version=version)
    index.commit(commit_msg)
    log.info('Update git index after commit: {}'.format(commit_msg))
    return index.write_tree()


def prepare_release(config, version, languages):
    """Prepare a new release in a given version."""
    basedir = get_repository_directory(config)
    repo = get_repository(basedir)
    # assert not repo.is_dirty(), 'Current head is dirty'
    # assert repo.active_branch.name == 'master', 'Not on master branch'
    tag_name = 'release-{}'.format(version)
    assert tag_name not in repo.tags, 'Tag {} exists'.format(version)

    # XXX Check uptodate with origin
    origin = repo.remote()
    assert origin.name == 'origin', 'Invalid remote origin'

    log.debug('Fetching origin')
    origin.fetch()

    orig_commit = origin.refs.master.commit.hexsha
    local_commit = repo.refs.master.commit.hexsha
    if local_commit != orig_commit:
        log.error('Out of sync with origin, local commit {}, expected {}'.
                  format(local_commit, orig_commit))
        sys.exit(1)

    output_directory = '{}/dist/{}'.format(basedir, version)
    if not os.path.isdir(output_directory):
        log.info('Creating output directory {}'.format(output_directory))
        os.mkdir(output_directory)

    all_packages = config.get('packages', {})
    for language, packages in all_packages.items():
        if 'all' not in languages and language not in languages:
            log.info('Skipping language {}'.format(language))
            continue

        if language in update_package_methods:
            fn = update_package_methods[language]
            if not fn:
                log.warn('Update package not implemented for language {}'.
                         format(language))
                continue
        else:
            log.error('Invalid language {}'.format(language))
            sys.exit(1)
        for package in packages:
            log.info('Updating package {} to version {}'.
                     format(package['name'], version))
            package_dir = '{}/{}'.format(basedir, package['path'])
            fn(package, package_dir, version)
    # XXX Update CHANGES.md
    # XXX Consider changelog

    # XXX Commit changes
    commit_release(repo, version)
    # XXX Make a release tag
    repo.create_tag(tag_name)
    log.info('Prepare of release {} done'.format(version))
    return True


# Methods factories
update_package_methods = {
    'python': update_python_version,
    'javascript': update_javascript_package,
    'golang': None
}

make_dist_methods = {
    'python': make_python_package,
    'javascript': make_javascript_package,
    'golang': make_go_distribution
}


if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('--conf', dest='conffile', default='package.yaml')
    parser.add_argument('--version', dest='version')
    parser.add_argument('--prepare', dest='do_prepare', action='store_true',
                        default=True)
    parser.add_argument('--build', dest='do_build', action='store_true',
                        default=False)
    parser.add_argument('--languages', dest='languages', default='all')
    opts = parser.parse_args(sys.argv[1:])

    with open(opts.conffile) as f:
        config = yaml.load(f.read())

    languages = opts.languages.split(',')

    if opts.do_prepare:
        prepare_release(config, opts.version, languages)
    if opts.do_build:
        make_packages(config, opts.version, languages)
