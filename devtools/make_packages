#!/bin/env python
"""Caliopen package creation logic.

Read package definition from a yaml file and build the corresponding
package depending on language.

cordova:
  lauguage: javascript
  description: an app packaged for android, ios & windows phone
  dependencies:
    nodejs: "^6.10"
  packages:
  - "/dist/android-app"
  - "/dist/ios-app"
  - "/dist/windows-phone-app"

# Python packages
caliopen_storage:
  language: python
  description: Caliopen python storage package
  dependencies:
    python: "^2.7"
  packages:
  - "/dist/python"

"""

import os
import sys
import subprocess as sp
import argparse
import re

import logging
import yaml

log = logging.getLogger(__name__)
logging.basicConfig()
log.setLevel(logging.DEBUG)


PY_BUILD_CMD = 'python setup.py bdist_wheel --universal --dist-dir {}'
# XXX well perl from python I know, don't find simplest way than this one
PY_VERSION_CMD = "perl -pi -e \"s/__version__ = '.*/__version__ = '{}'/\" {}"
JS_BUILD_CMD = 'yarn release:web:{}'
GO_BUILD_CMD = 'go build'


def do_package_command(package, cmd):
    """Execute a shell command for a package."""
    log.debug(' will execute command : {}'.format(cmd))
    errno = sp.call(cmd, shell=True)
    if errno == 0:
        log.info('Build python package {} OK'.format(package['name']))
        return True
    msg = 'Build python package {} failed: {}'.format(package['name'], errno)
    raise Exception(msg)


def update_python_version(package, package_dir, version):
    """Update python package version rewriting in place."""
    init_file = '{}/{}/__init__.py'.format(package_dir, package['name'])
    if not os.path.isfile(init_file):
        raise Exception('File {} for package version not found'.
                        format(init_file))
    """Update the __version__ value for a python package."""
    with open(init_file) as v_file:
        current = re.compile(r".*__version__ = '(.*?)'",
                             re.S).match(v_file.read()).group(1)

        t_ver = tuple(int(x) for x in version.split('.'))
        t_cur = tuple(int(x) for x in current.split('.'))
        if t_ver <= t_cur:
            raise Exception('Current version %s and expected one %s mismatch'.
                            format(current, version))
    # XXX rewrite init_file with new version
    cmd = PY_VERSION_CMD.format(version, init_file)
    log.debug('Updating python package {} to version {}'.
              format(package['name'], version))
    return do_package_command(package, cmd)


def make_javascript_package(package, directory, version, output_directory):
    """Build javascript distribution."""
    if not os.path.isdir(directory):
        raise Exception('No such package directory {}'.format(directory))
    cmd = 'cd {}; {}'.format(directory, JS_BUILD_CMD.format(package['name']))
    res = do_package_command(package, cmd)
    if not res:
        return False
    # Move build distribution
    distdir = '{}/dist/{}'.format(directory, package['name'])
    if not os.path.isdir(distdir):
        log.error('No dist directory after build')
        sys.exit(1)
    destdir = '{}/{}'.format(output_directory, package['name'])
    os.rename(distdir, destdir)
    return True


def make_go_distribution(package, directory, version, output_directory):
    """Build go binaries for a given package and version."""
    pass


def make_python_package(package, directory, version, output_directory):
    """Make a python wheel package for a given package and version."""
    if not os.path.isdir(directory):
        raise Exception('No such package directory {}'.format(directory))
    if not update_python_version(package, directory, version):
        log.warn('Update python package failed')
        return False

    build_cmd = PY_BUILD_CMD.format(output_directory)
    cmd = 'cd {}; {}'.format(directory, build_cmd)
    return do_package_command(package, cmd)


def make_packages(config, version):
    """Given a packages dict and a version, build all."""
    all_packages = config.get('packages', {})
    repo = config.get('repository', {})
    basedir = repo.get('base_directory')
    assert os.path.isdir(basedir)
    basepath = os.path.abspath(basedir)

    output_directory = '{}/dist/{}'.format(basepath, version)
    if not os.path.isdir(output_directory):
        log.info('Creating output directory {}'.format(output_directory))
        os.mkdir(output_directory)

    for language, packages in all_packages.items():
        if language == 'python':
            fn = make_python_package
        elif language == 'javascript':
            fn = make_javascript_package
        elif language == 'golang':
            fn = make_go_distribution
        else:
            log.error('Invalid language {}'.format(language))
            # sys.exit(1)

        for package in packages:
            log.info('Building package {}'.format(package['name']))
            package_dir = '{}/{}'.format(basepath, package['path'])
            fn(package, package_dir, version, output_directory)


if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('-f', dest='conffile', default='package.yaml')
    parser.add_argument('-v', dest='version')
    opts = parser.parse_args(sys.argv[1:])

    with open(opts.conffile) as f:
        config = yaml.load(f.read())

    make_packages(config, opts.version)
